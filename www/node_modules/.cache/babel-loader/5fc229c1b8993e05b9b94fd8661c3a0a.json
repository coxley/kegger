{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useWebSocket = void 0;\n\nvar react_1 = require(\"react\");\n\nvar react_dom_1 = require(\"react-dom\");\n\nvar constants_1 = require(\"./constants\");\n\nvar create_or_join_1 = require(\"./create-or-join\");\n\nvar get_url_1 = require(\"./get-url\");\n\nvar proxy_1 = __importDefault(require(\"./proxy\"));\n\nvar util_1 = require(\"./util\");\n\nvar useWebSocket = function useWebSocket(url, options, connect) {\n  if (options === void 0) {\n    options = constants_1.DEFAULT_OPTIONS;\n  }\n\n  if (connect === void 0) {\n    connect = true;\n  }\n\n  var _a = (0, react_1.useState)(null),\n      lastMessage = _a[0],\n      setLastMessage = _a[1];\n\n  var _b = (0, react_1.useState)({}),\n      readyState = _b[0],\n      setReadyState = _b[1];\n\n  var lastJsonMessage = (0, react_1.useMemo)(function () {\n    if (lastMessage) {\n      try {\n        return JSON.parse(lastMessage.data);\n      } catch (e) {\n        return constants_1.UNPARSABLE_JSON_OBJECT;\n      }\n    }\n\n    return null;\n  }, [lastMessage]);\n  var convertedUrl = (0, react_1.useRef)(null);\n  var webSocketRef = (0, react_1.useRef)(null);\n  var startRef = (0, react_1.useRef)(function () {\n    return void 0;\n  });\n  var reconnectCount = (0, react_1.useRef)(0);\n  var messageQueue = (0, react_1.useRef)([]);\n  var webSocketProxy = (0, react_1.useRef)(null);\n  var optionsCache = (0, react_1.useRef)(options);\n  optionsCache.current = options;\n  var readyStateFromUrl = convertedUrl.current && readyState[convertedUrl.current] !== undefined ? readyState[convertedUrl.current] : url !== null && connect === true ? constants_1.ReadyState.CONNECTING : constants_1.ReadyState.UNINSTANTIATED;\n  var stringifiedQueryParams = options.queryParams ? JSON.stringify(options.queryParams) : null;\n  var sendMessage = (0, react_1.useCallback)(function (message, keep) {\n    var _a;\n\n    if (keep === void 0) {\n      keep = true;\n    }\n\n    if (constants_1.isEventSourceSupported && webSocketRef.current instanceof EventSource) {\n      console.warn('Unable to send a message from an eventSource');\n      return;\n    }\n\n    if (((_a = webSocketRef.current) === null || _a === void 0 ? void 0 : _a.readyState) === constants_1.ReadyState.OPEN) {\n      (0, util_1.assertIsWebSocket)(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketRef.current.send(message);\n    } else if (keep) {\n      messageQueue.current.push(message);\n    }\n  }, []);\n  var sendJsonMessage = (0, react_1.useCallback)(function (message, keep) {\n    if (keep === void 0) {\n      keep = true;\n    }\n\n    sendMessage(JSON.stringify(message), keep);\n  }, [sendMessage]);\n  var getWebSocket = (0, react_1.useCallback)(function () {\n    if (optionsCache.current.share !== true || constants_1.isEventSourceSupported && webSocketRef.current instanceof EventSource) {\n      return webSocketRef.current;\n    }\n\n    if (webSocketProxy.current === null && webSocketRef.current) {\n      (0, util_1.assertIsWebSocket)(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketProxy.current = (0, proxy_1.default)(webSocketRef.current, startRef);\n    }\n\n    return webSocketProxy.current;\n  }, []);\n  (0, react_1.useEffect)(function () {\n    if (url !== null && connect === true) {\n      var removeListeners_1;\n      var expectClose_1 = false;\n      var createOrJoin_1 = true;\n\n      var start_1 = function start_1() {\n        return __awaiter(void 0, void 0, void 0, function () {\n          var _a, protectedSetLastMessage, protectedSetReadyState;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _a = convertedUrl;\n                return [4\n                /*yield*/\n                , (0, get_url_1.getUrl)(url, optionsCache)];\n\n              case 1:\n                _a.current = _b.sent();\n\n                protectedSetLastMessage = function protectedSetLastMessage(message) {\n                  if (!expectClose_1) {\n                    (0, react_dom_1.flushSync)(function () {\n                      return setLastMessage(message);\n                    });\n                  }\n                };\n\n                protectedSetReadyState = function protectedSetReadyState(state) {\n                  if (!expectClose_1) {\n                    (0, react_dom_1.flushSync)(function () {\n                      return setReadyState(function (prev) {\n                        var _a;\n\n                        return __assign(__assign({}, prev), convertedUrl.current && (_a = {}, _a[convertedUrl.current] = state, _a));\n                      });\n                    });\n                  }\n                };\n\n                if (createOrJoin_1) {\n                  removeListeners_1 = (0, create_or_join_1.createOrJoinSocket)(webSocketRef, convertedUrl.current, protectedSetReadyState, optionsCache, protectedSetLastMessage, startRef, reconnectCount, sendMessage);\n                }\n\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n\n      startRef.current = function () {\n        if (!expectClose_1) {\n          if (webSocketProxy.current) webSocketProxy.current = null;\n          removeListeners_1 === null || removeListeners_1 === void 0 ? void 0 : removeListeners_1();\n          start_1();\n        }\n      };\n\n      start_1();\n      return function () {\n        expectClose_1 = true;\n        createOrJoin_1 = false;\n        if (webSocketProxy.current) webSocketProxy.current = null;\n        removeListeners_1 === null || removeListeners_1 === void 0 ? void 0 : removeListeners_1();\n        setLastMessage(null);\n      };\n    } else if (url === null || connect === false) {\n      reconnectCount.current = 0; // reset reconnection attempts\n\n      setReadyState(function (prev) {\n        var _a;\n\n        return __assign(__assign({}, prev), convertedUrl.current && (_a = {}, _a[convertedUrl.current] = constants_1.ReadyState.CLOSED, _a));\n      });\n    }\n  }, [url, connect, stringifiedQueryParams, sendMessage]);\n  (0, react_1.useEffect)(function () {\n    if (readyStateFromUrl === constants_1.ReadyState.OPEN) {\n      messageQueue.current.splice(0).forEach(function (message) {\n        sendMessage(message);\n      });\n    }\n  }, [readyStateFromUrl]);\n  return {\n    sendMessage: sendMessage,\n    sendJsonMessage: sendJsonMessage,\n    lastMessage: lastMessage,\n    lastJsonMessage: lastJsonMessage,\n    readyState: readyStateFromUrl,\n    getWebSocket: getWebSocket\n  };\n};\n\nexports.useWebSocket = useWebSocket;","map":{"version":3,"mappings":"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","names":["useWebSocket","url","options","connect","constants_1","lastMessage","setLastMessage","readyState","setReadyState","lastJsonMessage","JSON","parse","data","e","convertedUrl","webSocketRef","startRef","reconnectCount","messageQueue","webSocketProxy","optionsCache","current","readyStateFromUrl","undefined","CONNECTING","UNINSTANTIATED","stringifiedQueryParams","queryParams","stringify","sendMessage","message","keep","EventSource","console","warn","_a","OPEN","skipAssert","send","push","sendJsonMessage","getWebSocket","share","removeListeners_1","expectClose_1","createOrJoin_1","start_1","_b","protectedSetLastMessage","protectedSetReadyState","state","prev","CLOSED","splice","forEach","exports"],"sources":["/home/coxley/kegger/web/node_modules/react-use-websocket/src/lib/use-websocket.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback, useMemo } from 'react';\nimport { flushSync } from 'react-dom';\nimport { DEFAULT_OPTIONS, isEventSourceSupported, ReadyState, UNPARSABLE_JSON_OBJECT } from './constants';\nimport { createOrJoinSocket } from './create-or-join';\nimport { getUrl } from './get-url';\nimport websocketWrapper from './proxy';\nimport {\n  Options,\n  ReadyStateState,\n  SendMessage,\n  SendJsonMessage,\n  WebSocketMessage,\n  WebSocketHook,\n  WebSocketLike,\n  JsonValue,\n} from './types';\nimport { assertIsWebSocket } from './util';\n\nexport const useWebSocket = <T extends JsonValue | null = JsonValue | null>(\n  url: string | (() => string | Promise<string>) | null,\n  options: Options = DEFAULT_OPTIONS,\n  connect: boolean = true,\n): WebSocketHook<T> => {\n  const [lastMessage, setLastMessage] = useState<WebSocketEventMap['message'] | null>(null);\n  const [readyState, setReadyState] = useState<ReadyStateState>({});\n  const lastJsonMessage: T = useMemo(() => {\n    if (lastMessage) {\n      try {\n        return JSON.parse(lastMessage.data);\n      } catch (e) {\n        return UNPARSABLE_JSON_OBJECT;\n      }\n    }\n    return null; \n  },[lastMessage]);\n  const convertedUrl = useRef<string | null>(null);\n  const webSocketRef = useRef<WebSocketLike | null>(null);\n  const startRef = useRef<() => void>(() => void 0);\n  const reconnectCount = useRef<number>(0);\n  const messageQueue = useRef<WebSocketMessage[]>([]);\n  const webSocketProxy = useRef<WebSocketLike | null>(null);\n  const optionsCache = useRef<Options>(options);\n  optionsCache.current = options;\n\n  const readyStateFromUrl: ReadyState =\n    convertedUrl.current && readyState[convertedUrl.current] !== undefined ?\n      readyState[convertedUrl.current] :\n      url !== null && connect === true ?\n        ReadyState.CONNECTING :\n        ReadyState.UNINSTANTIATED;\n\n  const stringifiedQueryParams = options.queryParams ? JSON.stringify(options.queryParams) : null;\n\n  const sendMessage: SendMessage = useCallback((message, keep = true) => {\n    if (isEventSourceSupported && webSocketRef.current instanceof EventSource) {\n      console.warn('Unable to send a message from an eventSource');\n      return;\n    }\n  \n    if (webSocketRef.current?.readyState === ReadyState.OPEN) {\n      assertIsWebSocket(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketRef.current.send(message);\n    } else if (keep) {\n      messageQueue.current.push(message);\n    }\n  }, []);\n\n  const sendJsonMessage: SendJsonMessage = useCallback((message, keep = true) => {\n    sendMessage(JSON.stringify(message), keep);\n  }, [sendMessage]);\n  \n  const getWebSocket = useCallback(() => {\n    if (optionsCache.current.share !== true || (isEventSourceSupported && webSocketRef.current instanceof EventSource)) {\n      return webSocketRef.current;\n    }\n\n    if (webSocketProxy.current === null && webSocketRef.current) {\n      assertIsWebSocket(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketProxy.current = websocketWrapper(webSocketRef.current, startRef);\n    }\n\n    return webSocketProxy.current;\n  }, []);\n\n  useEffect(() => {\n    if (url !== null && connect === true) {\n      let removeListeners: () => void;\n      let expectClose = false;\n      let createOrJoin = true;\n\n      const start = async () => {\n        convertedUrl.current = await getUrl(url, optionsCache);\n\n        const protectedSetLastMessage = (message: WebSocketEventMap['message']) => {\n          if (!expectClose) {\n            flushSync(() => setLastMessage(message));\n          }\n        };\n  \n        const protectedSetReadyState = (state: ReadyState) => {\n          if (!expectClose) {\n            flushSync(() => setReadyState(prev => ({\n              ...prev,\n              ...(convertedUrl.current && {[convertedUrl.current]: state}),\n            })));\n          }\n        };\n\n        if(createOrJoin) {\n          removeListeners = createOrJoinSocket(\n            webSocketRef,\n            convertedUrl.current,\n            protectedSetReadyState,\n            optionsCache,\n            protectedSetLastMessage,\n            startRef,\n            reconnectCount,\n            sendMessage,\n          );\n        }\n      };\n\n      startRef.current = () => {\n        if (!expectClose) {\n          if (webSocketProxy.current) webSocketProxy.current = null;\n          removeListeners?.();\n          start();\n        }\n      };\n    \n      start();\n      return () => {\n        expectClose = true;\n        createOrJoin = false;\n        if (webSocketProxy.current) webSocketProxy.current = null;\n        removeListeners?.();\n        setLastMessage(null);\n      };\n    } else if (url === null || connect === false) {\n      reconnectCount.current = 0; // reset reconnection attempts\n      setReadyState(prev => ({\n        ...prev,\n        ...(convertedUrl.current && {[convertedUrl.current]: ReadyState.CLOSED}),\n      }));\n    }\n  }, [url, connect, stringifiedQueryParams, sendMessage]);\n\n  useEffect(() => {\n    if (readyStateFromUrl === ReadyState.OPEN) {\n      messageQueue.current.splice(0).forEach(message => {\n        sendMessage(message);\n      });\n    }\n  }, [readyStateFromUrl]);\n\n  return {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage,\n    lastJsonMessage,\n    readyState: readyStateFromUrl,\n    getWebSocket,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}